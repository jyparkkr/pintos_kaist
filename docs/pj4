+-------------------------+
|        EE 415           |
|      PROJECT 3          |
|  DESIGN DOCUMENT        |
+-------------------------+
---- GROUP ----
20170088 김문성 ms721@kaist.ac.kr
20170276 박재영 jypark_korea@kaist.ac.kr

---- PRELIMINARIES ----
>> If you have any preliminary comments on your submission, notes for
>> the TAs, or extra credit, please give them here.

No comments

>> Please cite any oﬄine or online sources you consulted while
>> preparing your submission, other than the Pintos documentation,
>> course text, and lecture notes.
Lecture note of Pintos Project Slide Set in https://oslab.kaist.ac.kr/ee415-spring-2020/.

Buffer Cache
=====================
---- DATA STRUCTURES ----
>>new or changes 'struct'
In pintos_kaist/src/filesys/buffer_cache.h
We made a structure for buffer head.
struct buffer_head{
  // Flag that tells if corresponding entry is dirty
  bool dirty;
  // Flag that tells if corresponding entry is used
  bool used;
  // disk sector address of corresponding entry
  block_sector_t disk_addr;
  // clock bit for clock algorithm
  bool clock;
  // lock variable
  struct lock lock;
  // data pointer to point buffer cache entry
  void *buffer;
};

>>Added global variable
In pintos_kaist/src/filesys/buffer_cache.c

/*BUFFER_CACHE_ENTRY_NB : number of buffer cache entry which is 64 (32kb)*/
#define BUFFER_CACHE_ENTRY_NB 64
/* p_buffer_cache[]: array that pointing buffer cache memory space*/
static char p_buffer_cache[BUFFER_CACHE_ENTRY_NB * BLOCK_SECTOR_SIZE];
/*buffer_head[]: buffer head array*/
static struct buffer_head buffer_head[BUFFER_CACHE_ENTRY_NB];
/*clock_hand : variable for clock algorithm when selecting victim entry*/
static struct buffer_head *clock_hand;

---- ALGORITHMS ----
>> Brieﬂy describe your implementation for buffer_cache
 In current pintos, when we deal with files, brings it from disk. 
 So by make buffer cache, we keep disk block in the memory space to reduce I/O time. 
 When file_read() called, it calls inode_read_at() and then it calls bc_read(). 
 When bc_read() is called, it looks for every buffer_head entries if there is 
 corresponding file in buffer cache. If there is, read file from buffer cache. 
 If there is no corresponding file in buffer cache, corresponding file is in disk. 
 Then we should bring it to the buffer_cache. 
 So we find the buffer_head to keep file from disk. 
 We find choose such buffer head by bc_select_victim(). 
 The algorithm of bc_select victim will be explained later. 
 So after choosing the buffer head, read the file from disk to buffer cache by block_read().
  Then read the data from buffer cache to buffer and update buffer_head.
 When bc_write() is called, it calls inode_write_at(), then bc_write() is called. 
 From here, samething occurs until read data from disk to buffer_cache by block_read(). 
 Then write data from buffer to buffer cache.
 So the algorithm to find the buffer head to keep data from disk is following. 
 I used clock algorithm. There is bool used, and bool clock, 
 in struct buffer_head. So from current clock hand, 
 we search every buffer head entry by loop. For every buffer head, 
 if the buffer is empty(used flag is 0), return that entry. 
 If the buffer is used, check if the clock bit is 0. 
 If 1, change the clock bit to 0 and go to next entry. 
 If clock bit is 0, check if the dirty flag is 1. If 1, flush that entry to disk. 
 And return that entry. If 0, just return the entry. 
 This is the clock algorithm to select the buffer entry.

---- RATIONALE ----
If we go through make check at pintos/src/filesystem, 
only syn-read in the examples is fail. So in total, 43 of 121 tests failed.

Extensible file
=====================
---- DATA STRUCTURES ----
>>new or changes 'struct'
>>Added global variable
1) Struct inode_disk is edited since inode doesn't include inode_disk.
struct inode_disk
  {
    //block_sector_t start;               /* First data sector. */
    off_t length;                       /* File size in bytes. */
    unsigned magic;                     /* Magic number. */
    //uint32_t unused[125];               /* Not used. */

    uint32_t is_dir;                        /*0 for file, 1 for dir*/

    /* Data containing disk sector. -1 for unassigned */
    block_sector_t direct_map_table[DIRECT_BLOCK_ENTRIES];  
    /* Indirect block which contains data blocks */
    block_sector_t indirect_block_sec;
    /* Double indirect block which contains indirect blocks */
    block_sector_t double_indirect_block_sec;
  };

2) enum direct_t is added for disk block type.
/* The way inode points disk block */
enum direct_t
{
  NORMAL_DIRECT,      /* Inode save disk block num */
  INDIRECT,           /* Access by one index block */
  DOUBLE_INDIRECT,    /* Access by two index block */
  OUT_LIMIT           /* Wrong file offset */
};

3) Struct inode_indirect_block is added to imply indirect inode block.
struct sector_location
  {
    uint8_t directness;  /* Way to access disk block - from direct_t */
    int index1;           /* Entry offset for first index block */
    int index2;           /* Entry offset for second index block */
  };

4) Semapore lock is added on struct inode.
struct inode 
  {
    ...
    struct lock extend_lock;            /* Semaphore lock */
  };

>>Added global variable
1) Macro DIRECT_BLOCK_ENTRIES added on inode.c
It is defined as 124(125 - 3 + 2).

2) Macro INDIRECT_BLOCK_ENTRIES is added to make indirect block size
is equal to block sector size.

---- ALGORITHMS ----
In previous Pintos, file size is fixed on file creation, and cannot be
edited after. Purpose of "Extensible File" is to extend this limit.
When file is newly written, make pintos to allocate new disk block and
write on it.

Key feature is changing inode structrue by direct, indirect and double indirect way.
Direct block just directly points Data blocks, indirect pointer points block
which points data blocks, and double indirect block points indirect blocks 
which points direct blocks. To find appropreiate disk block, structure 
sector_location is used. Also, func. get_disk_inode is used to get data of 
disk_inode from disk sector since in-memory inode is only containing sector
of disk_inode. It means that in-memory inode and disk inode is not directly
connected. For update, func. inode_update_file_length is used. It writes changed region
on disk sector. 

---- RATIONALE ----
All tests for filesystem are passed.


Subdirectory
=====================
---- DATA STRUCTURES ----
>>new or changes 'struct'
1) On struct inode_disk, uint32_t is_dir is added for subdirectory.
struct inode_disk
  {
    ...
    uint32_t is_dir;                        /*0 for file, 1 for dir*/
    ...
  };

2) On struct thread, cur_dir is added to save current working directory.
struct thread
  {
    ...
    struct dir *cur_dir;         /*current directory*/
  };

>>Added global variable
1) Macro DIRECT_BLOCK_ENTRIES 123 (124 - 123 since is_dir is added)

2) Macro PATH_MAX_LEN 256 for char limit on path.

---- ALGORITHMS ----
>> Brieﬂy describe your implementation for subdirectory
First set is_dir values when initializing. For example at such functions below
dir_create() in pintos_kaist/src/filesys/directory.c, 
filesys_crete() in pintos_kaist/src/filesys/filesys.c, 
free_map_create() in pintos_kaist/src/filesys/free-map.c

When setting current directory, set the field added in struct thread as a root directory
 in filesys_init(). Then when we create thread, set child's directory by reopen parent 
 thread's directory. So add below at thread_create() in pintos_kaist/src/threads/thread.c

if(thread_current()->cur_dir != NULL){
    /* set child thread's directory to parent's directory by reopen the directory*/
    t->cur_dir = dir_reopen(thread_current()->cur_dir);
  }

When we get path, we use parse_path in pintos_kaist/src/filesys/filesys.c to analyze it.

/* Parse input in path_name to 
  path to path_name
  file to file_name. */
struct dir* parse_path (char *path_name, char *file_name) {
  struct dir *dir = NULL;
  if (path_name == NULL || file_name == NULL)
    return NULL;
  if (strlen(path_name) == 0)
    return NULL;
  /* To remain path_name */
  char path_tok[PATH_MAX_LEN+1];
  strlcpy (path_tok, path_name, PATH_MAX_LEN);
  if (path_tok[0] == '/')
    dir = dir_open_root ();
  else
    dir = dir_reopen (thread_current ()->cur_dir);

  if (!inode_is_dir (dir_get_inode (dir)))
    return NULL;
  char *token, *nextToken, *savePtr;
  token = strtok_r (path_tok, "/", &savePtr);
  nextToken = strtok_r (NULL, "/", &savePtr);
  if (token == NULL)
  {
    strlcpy (file_name, ".", PATH_MAX_LEN);
    return dir;
  }
  while (token != NULL && nextToken != NULL){
    struct inode *inode = NULL;
    if (!dir_lookup (dir, token, &inode))
    {
      dir_close (dir);
      return NULL;
    }
    if (!inode_is_dir (inode))
    {
      dir_close (dir);
      return NULL;
    }
    dir_close (dir);
    dir = dir_open (inode);

    token = nextToken;
    nextToken = strtok_r (NULL, "/", &savePtr);
  }
  strlcpy (file_name, token, PATH_MAX_LEN);
  return dir;
}

Here when we get path_name and file_name, parse the path_name and make file_name to point 
the name of file/directory. Classify if it is absolute path or relative path with the fact 
if the the path_name start with '/'. And parse the path_name string using strtok_r.
dir will point the opened directory and this function will return the pointer to current 
working directory. More specific explain is on the code as a comment.

In filesys_create(), filesys_open, filesys_remove() in pintos_kaist/src/filesys/filesys.c,
Originally, they set the directory as root by dir_open_root(). Because there was only one 
directory root. However, the subdirectory is implemented, so this part is changed.
Instead using dir_open_root(), we use parse_path() to get the directory and file_name.
Moreover, in filesys_remove(), check if in-memory inode of file_name is file or directory. 
If inode is directory, check whether file is in directory. If file doesn’t exist, delete 
file_name entry from directory. If inode is a file, delete file_name entry from directory.

Remove system call was changed with filesys_remove(). It checks absolute and relative path
by parse_path() - which mentioned above. 

---- RATIONALE ----
In filesys_remove(), it updates file length on inode_disk but cannot make it short.
This is basic problem of the code since register_sector() on inode.c doesn't find empty
slot of sector. So block sector is not optimized and length of inode_disk is just implying
maximum allocated location.

Also during test, all persistence test not only failed but also stopped qemu system.
For example, the command below (which is produced by make check)
pintos -v -k -T 60  --qemu --disk=tmp.dsk -g fs.tar -a tests/filesys/extended/dir-rm-cwd.tar
 -- -q  run 'tar fs.tar /' < /dev/null 2> tests/filesys/extended/dir-rm-cwd-persistence.errors
  > tests/filesys/extended/dir-rm-cwd-persistence.output
works on terminal, but on make check, it makes the error like the sentence below.
make: *** [tests/filesys/extended/dir-rm-cwd.output] Error 255
Still, typing make check continues grading.

It passed all tests but tests/filesys/extended/dir-vine and persistence test. (24/121 failed)

Detailed results are on below.
pass tests/userprog/args-none
pass tests/userprog/args-single
pass tests/userprog/args-multiple
pass tests/userprog/args-many
pass tests/userprog/args-dbl-space
pass tests/userprog/sc-bad-sp
pass tests/userprog/sc-bad-arg
pass tests/userprog/sc-boundary
pass tests/userprog/sc-boundary-2
pass tests/userprog/halt
pass tests/userprog/exit
pass tests/userprog/create-normal
pass tests/userprog/create-empty
pass tests/userprog/create-null
pass tests/userprog/create-bad-ptr
pass tests/userprog/create-long
pass tests/userprog/create-exists
pass tests/userprog/create-bound
pass tests/userprog/open-normal
pass tests/userprog/open-missing
pass tests/userprog/open-boundary
pass tests/userprog/open-empty
pass tests/userprog/open-null
pass tests/userprog/open-bad-ptr
pass tests/userprog/open-twice
pass tests/userprog/close-normal
pass tests/userprog/close-twice
pass tests/userprog/close-stdin
pass tests/userprog/close-stdout
pass tests/userprog/close-bad-fd
pass tests/userprog/read-normal
pass tests/userprog/read-bad-ptr
pass tests/userprog/read-boundary
pass tests/userprog/read-zero
pass tests/userprog/read-stdout
pass tests/userprog/read-bad-fd
pass tests/userprog/write-normal
pass tests/userprog/write-bad-ptr
pass tests/userprog/write-boundary
pass tests/userprog/write-zero
pass tests/userprog/write-stdin
pass tests/userprog/write-bad-fd
pass tests/userprog/exec-once
pass tests/userprog/exec-arg
pass tests/userprog/exec-multiple
pass tests/userprog/exec-missing
pass tests/userprog/exec-bad-ptr
pass tests/userprog/wait-simple
pass tests/userprog/wait-twice
pass tests/userprog/wait-killed
pass tests/userprog/wait-bad-pid
pass tests/userprog/multi-recurse
pass tests/userprog/multi-child-fd
pass tests/userprog/rox-simple
pass tests/userprog/rox-child
pass tests/userprog/rox-multichild
pass tests/userprog/bad-read
pass tests/userprog/bad-write
pass tests/userprog/bad-read2
pass tests/userprog/bad-write2
pass tests/userprog/bad-jump
pass tests/userprog/bad-jump2
pass tests/filesys/base/lg-create
pass tests/filesys/base/lg-full
pass tests/filesys/base/lg-random
pass tests/filesys/base/lg-seq-block
pass tests/filesys/base/lg-seq-random
pass tests/filesys/base/sm-create
pass tests/filesys/base/sm-full
pass tests/filesys/base/sm-random
pass tests/filesys/base/sm-seq-block
pass tests/filesys/base/sm-seq-random
pass tests/filesys/base/syn-read
pass tests/filesys/base/syn-remove
pass tests/filesys/base/syn-write
pass tests/filesys/extended/dir-empty-name
pass tests/filesys/extended/dir-mk-tree
pass tests/filesys/extended/dir-mkdir
pass tests/filesys/extended/dir-open
pass tests/filesys/extended/dir-over-file
pass tests/filesys/extended/dir-rm-cwd
pass tests/filesys/extended/dir-rm-parent
pass tests/filesys/extended/dir-rm-root
pass tests/filesys/extended/dir-rm-tree
pass tests/filesys/extended/dir-rmdir
pass tests/filesys/extended/dir-under-file
FAIL tests/filesys/extended/dir-vine
pass tests/filesys/extended/grow-create
pass tests/filesys/extended/grow-dir-lg
pass tests/filesys/extended/grow-file-size
pass tests/filesys/extended/grow-root-lg
pass tests/filesys/extended/grow-root-sm
pass tests/filesys/extended/grow-seq-lg
pass tests/filesys/extended/grow-seq-sm
pass tests/filesys/extended/grow-sparse
pass tests/filesys/extended/grow-tell
pass tests/filesys/extended/grow-two-files
pass tests/filesys/extended/syn-rw
FAIL tests/filesys/extended/dir-empty-name-persistence
FAIL tests/filesys/extended/dir-mk-tree-persistence
FAIL tests/filesys/extended/dir-mkdir-persistence
FAIL tests/filesys/extended/dir-open-persistence
FAIL tests/filesys/extended/dir-over-file-persistence
FAIL tests/filesys/extended/dir-rm-cwd-persistence
FAIL tests/filesys/extended/dir-rm-parent-persistence
FAIL tests/filesys/extended/dir-rm-root-persistence
FAIL tests/filesys/extended/dir-rm-tree-persistence
FAIL tests/filesys/extended/dir-rmdir-persistence
FAIL tests/filesys/extended/dir-under-file-persistence
FAIL tests/filesys/extended/dir-vine-persistence
FAIL tests/filesys/extended/grow-create-persistence
FAIL tests/filesys/extended/grow-dir-lg-persistence
FAIL tests/filesys/extended/grow-file-size-persistence
FAIL tests/filesys/extended/grow-root-lg-persistence
FAIL tests/filesys/extended/grow-root-sm-persistence
FAIL tests/filesys/extended/grow-seq-lg-persistence
FAIL tests/filesys/extended/grow-seq-sm-persistence
FAIL tests/filesys/extended/grow-sparse-persistence
FAIL tests/filesys/extended/grow-tell-persistence
FAIL tests/filesys/extended/grow-two-files-persistence
FAIL tests/filesys/extended/syn-rw-persistence
24 of 121 tests failed.



