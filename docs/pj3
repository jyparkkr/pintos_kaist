+-------------------------+
|          EE 415         |
|         PROJECT 3       |
|      DESIGN DOCUMENT    |
+-------------------------+

---- GROUP ----

20170088 김문성 ms721@kaist.ac.kr
20170276 박재영 jypark_korea@kaist.ac.kr

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for
>> the TAs, or extra credit, please give them here.

No comments

>> Please cite any oﬄine or online sources you consulted while
>> preparing your submission, other than the Pintos documentation,
>> course text, and lecture notes.

Lecture note of Pintos Project Slide Set in https://oslab.kaist.ac.kr/ee415-spring-2020/.
Lab note of LAB3 on Sungkyunkwan (SKKU) http://csl.skku.edu/uploads/SWE3004S15/project3.pdf


vm_entry
=========


---- DATA STRUCTURES ----

>>new or changed 'struct'

We newly made two files pintos_kaist/src/vm/page.h, pintos_kaist/src/vm/page.c
In pintos/src/vm/page.h, there is newly made struct vm_entry
which is composed with below.
    
struct vm_entry{
	uint8_t type; /* type for VM_BIN, VM_FILE, VM_ANON */
	void *vaddr; /* virtual page number that vm_entry manages*/
	bool writable; /* If True writable on corresponding address, If false not*/

	bool is_loaded; /* flag that tells us if is_loaded on physical memory */
	struct file* file; /* file that is mapped with virtual address */
	
	/* Will be used at Memory Mapped File*/
	struct list_elem mmap_elem; /* mmap list element */
	
	size_t offset; /* offset of file that will read*/
	size_t read_bytes; /* data size written on virtual page */
	size_t zero_bytes; /* left bytes that will be filled with 0*/
	
	/* Will be used on Swapping*/
	size_t swap_slot; /* swap slot */

	/* Will be used on ‘struct for vm_entries’*/
	struct hash_elem elem; /* hash table Element */
};

There is also a change at struct thread in pintos_kaist/src/threads/thread.h
/*For pj3 virtual memory*/
struct hash vm; /* Hashtable for virtual address space that thread owns*/
added.


---- ALGORITHMS ----

>> Brieﬂy describe your implementation of vm_entry

Every pages will have one vm_entry.
It saves file pointer, offset, size of each page.
When first load the program, allocate vm_entry on each page of virtual address space
When run program
->search the page table
->when page fault occurs, search vm_entry correspond to virtual address
--->If virtual address not in vm_entry, Segmentation fault
--->If vm_entry exist
----->allocate page frame
----->load page refer to the file pointer, offset, size and so on in the vm_entry
----->update page table

Also made many functions that deal with vm_entries.
void vm_init (struct hash *vm);   //initializes hash table vm
bool insert_vme (struct hash *vm, struct vm_entry *vme); //insert vme into vm
bool delete_vme (struct hash *vm, struct vm_entry *vme); //delete vme from vm
struct vm_entry *find_vme (void *vaddr); //find vm_entry using address *vaddr
void vm_destroy (struct hash *vm); // destroy hashtable vm



Demand paging
=============

---- ALGORITHMS ----


>> Brieﬂy describe your implementation of vm_entry

1. 
In pintos_kaist/src/userprog/process.c there is 
static bool
load_segment (struct file *file, off_t ofs, uint8_t *upage,
              uint32_t read_bytes, uint32_t zero_bytes, bool writable)
Here, loading segment of ELF format file on process virtual address space take place.
This is modified.
The part loading memory on virtual address space deleted.
Instead, vm_entry initializing is added.
allocate vm_entry structure, initialize field values, insert vm_entry to hashtable.


2. 
In pintos_kaist/src/userprog/process.c there is
static bool setup_stack (void **esp)

There are some functionalities added.
create 4KB vm_entry
initialize the field values of created vm_entry
insert to hashtable vm


3.
In pintos_kaist/src/userprog/syscall.c
There are functions for checking validity.
When checking, it previously just checked the validity of address.
From now on, chaged check_address function and 
added check_string, check_buffer function will check more deeply.
Even the address is valid, we will check whether vm_entry correspond to the address/buffer/string exist.


4.
In pintos_kaist/src/userprog/exception.c
There is static void page_fault (struct intr_frame *f) which manages page fault.
Previously, segmentation fault occurs and kill(-1) the process 
if there is an error on permission and address validity test.
From now on, if the addr is valid, search for vm_entry.
If there is, allocate pages, load from file to physical memory, set up page table 


5.
The process of allocate pages, load from file to physical memory, set up page table takes place by
bool handle_mm_fault (struct vm_entry *vme)  in pintos_kaist/src/userprog/process.c
This is newly added function. If handle_mm_fault is called,
first allocate physical memory, manage vm_entry by its type using switch case.
If type is VM_BIN, load to physical memory by 
bool load_file (void* kaddr, struct vm_entry *vme) in pintos_kaist/src/vm/page.c .
Then, map physical page and virtual page 
by static bool
install_page (void *upage, void *kpage, bool writable) in pintos_kaist/src/userprog/process.c


---- RATIONALE ----

every test passed related to Demanding pages.
I tested by make check on pintos_kaist/src/vm.
The result was 28 of 109 tests failed, which is the same value with lab pdf.

Memory Mapped File
=============
>> new or changed 'struct'
1. For mapid, datatype(typedef int mapid_t) and macro (#define MAPID_ERROR) added
2. In struct thread, mapid_t next_mapid is added. This starts from 0 and it implies next mapid number.
3. struct mmap_file is added on page.h
struct mmap_file {
    int mapid;
    struct file* file;		/* file pointer in mem */
    struct list_elem elem;	/* for thread's mmap_list */
    struct list vme_list;	/* its vm entry list */
};


>> Added global variables


---- ALGORITHMS ----
Current pintos doesn't have mmap and munmap system call.
mmap() is function that loads file data to memory by demand paging
munmap() remove the mapping above
Mmap first make mapping file structure and make vm_entrys of file. Because file can be too large to 
contain on single slot, this problem can be solve by make linked list of vm_entry and insert data on it.
Interesting thing is that thread can search for vm_entry by mmap_list if there is information of file or
hash table of vm if there is information of address.
When data is modified, it should be updated to drive. To check this perspective, munmap check modification
by bool pagedir_is_dirty() and write on disk by file_write_at (). 


---- RATIONALE ----
It passed all test from memory mapped file and shows 10 of 109 tests failed.

Swapping
=============
>> new or changed 'struct'
1. size_t swap_slot was added on vm_entry to show its swapped entry on swap disk if it is swapped out.

2. struct page  is added on page.h
struct page {
	void *kaddr;			/* physical addr of page */
	struct vm_entry *vme;	/* points vm_entry linked with physical page */
	struct thread *thread;	/* points thread_current */
	struct list_elem lru;	/* for connection with lru_list */
};



>> Added global variables
1. In frame.c global variables for swap policy was added.
struct list lru_list;
struct lock lru_list_lock;
struct list_elem *lru_clock;
was added on this feature.
Although name of global variables include lru, its swapping policy I choose to use is clock algorithm.
lru_clock is clock arm of this algorithm.

2. size of swap slot (#define SWAP_SLOT_SIZE 4096)  is added on swap.c to calculate number of block sector
needed for one swap slot and to calculate initial bitmap(for swap disk management) size.

3. lock filesys_lock moves syscall to thread.h because when file write, this lock is used.

---- ALGORITHMS ----
To use memory efficiently, choose page to swap by LRU-based algorithm (in this code, I use clock algorithm).
When page is choosed as victim then save it to swap area(which is swap-in). When process need the page then
swap out it (load on memory).
Clock algorithm is circular way of check, which is similar to round robin but check accessed bit which is 
true when the page is recently accessed. When the page is selected as candidate of victim then check 
accessed bit whether it is true or false. If it is true then change it to false and point next page, if false
then choose as victim to swap out.
Also if there is modification on file then it needs to be updated to disk. It is held by dirty bit. If dirty
bit is 1, it implies that those page should be updated to disk. To check empty swap disk, 
bitmap is used to check which is empty.  
Finally, edit action on page fault to get extra memory by clock algorithm.


---- DISCUSSIONS ----
On try_to_free_pages() on swap.c, ppt recommand to use palloc_flag parameter, but since there is no parameter
on page which have palloc_flags as its parameter, I just ignore input on try_to_free_pages()

On setup_stack, location of insert_vme() was important. This should be below to adding vme->addr information.
First, I wrote a code regardless of this information, but during debugging, I got intuition by funcion
struct vm_entry *find_vme(void *addr) which make new entry (not by pointer) and find corresponding address on vm.


---- RATIONALE ----
It pass all test for swapping and shows 6 of 109 tests failed.
(failed on page-parallel)

